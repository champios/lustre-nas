
 fs/ext4/exports.c |   74 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 73 insertions(+), 1 deletion(-)

--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5964,3 +5964,71 @@ out_unlock:
 	up_read(&inode->i_alloc_sem);
 	return ret;
 }
+
+int ext4_map_inode_page(struct inode *inode, struct page *page,
+			unsigned long *blocks, int *created, int create)
+{
+	unsigned int blocksize, blocks_per_page;
+	unsigned long iblock;
+	struct buffer_head dummy;
+	void *handle;
+	int i, rc = 0, failed = 0, needed_blocks;
+
+	blocksize = inode->i_sb->s_blocksize;
+	blocks_per_page = PAGE_SIZE >> inode->i_sb->s_blocksize_bits;
+	iblock = page->index * blocks_per_page;
+
+	for (i = 0; i < blocks_per_page; i++, iblock++) {
+		blocks[i] = ext4_bmap(inode->i_mapping, iblock);
+		if (blocks[i] == 0) {
+			failed++;
+			if (created)
+				created[i] = -1;
+		} else if (created) {
+			created[i] = 0;
+		}
+	}
+
+	if (failed == 0 || create == 0)
+		return 0;
+
+	needed_blocks = ext4_writepage_trans_blocks(inode);
+	handle = ext4_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+
+	iblock = page->index * blocks_per_page;
+	for (i = 0; i < blocks_per_page; i++, iblock++) {
+		struct ext4_map_blocks map;
+		if (blocks[i] != 0)
+			continue;
+
+		map.m_lblk = iblock;
+		map.m_len = 1;
+		rc = ext4_ind_map_blocks(handle, inode, &map,
+					 EXT4_GET_BLOCKS_CREATE);
+		if (rc < 0) {
+			printk(KERN_INFO "ext4_map_inode_page: error reading "
+					"block %ld\n", iblock);
+			goto out;
+		} else {
+			if (rc > 1)
+				WARN_ON(1);
+			rc = 0;
+		}
+		/* Unmap any metadata buffers from the block mapping, to avoid
+		 * data corruption due to direct-write from Lustre being
+		 * clobbered by a later flush of the blockdev metadata buffer.*/
+		if (buffer_new(&dummy))
+			unmap_underlying_metadata(dummy.b_bdev,
+					dummy.b_blocknr);
+		blocks[i] = dummy.b_blocknr;
+		if (created)
+			created[i] = 1;
+	}
+
+out:
+	ext4_journal_stop(handle);
+	return rc;
+}
+EXPORT_SYMBOL(ext4_map_inode_page);
